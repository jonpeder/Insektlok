x2 = (x2*10^4+6)/10^4
y2 = (y2*10^4+17)/10^4
# Search for a locality name within the given coordinates
xURL <- paste("https://ws.geonorge.no/SKWS3Index/ssr/sok?nordLL=", x1, "&ostLL=", y1, "&nordUR=", x2, "&ostUR=", y2, "&epsgKode=", 4258, sep = "")
xml_temp <- getURL(xURL, .encoding = "latin1")
xml_temp2<- xmlTreeParse(xml_temp, useInternalNodes = TRUE)
Loc_df <- xmlToDataFrame(xml_temp2)
#Stop loop at first hit
if (is.null(Loc_df[3,8])==FALSE) {
break
}
else {
next
}
}
# Calculate distnce and angle between input coordinates and locality-name
A <- as.numeric(Loc_df[3,9])
B <- as.numeric(Loc_df[3,10])
D <- points2dist(A, B, y, x)
A <- points2angle(A, B, y, x)
# Add search results to input table
output$county[i] <- Loc_df[3,7]
output$municipality[i] <- Loc_df[3,6]
output$locality[i] <- Loc_df[3,8]
output$type[i] <- Loc_df[3,5]
output$dist_m[i] <- round(D)
output$orient[i] <- A
}
return(output)
}
test <- read.table("koordinater.txt")
View(test)
test <- read.table("koordinater.txt", header = TRUE)
test <- read.table("koordinater.txt", header = TRUE, row.names = FALSE)
stedsnavn(test$Longitude, test$Latitude)
library(RCurl)
stedsnavn(test$Longitude, test$Latitude)
library(XML)
stedsnavn(test$Longitude, test$Latitude)
source("R/points2dist.R")
source("R/points2angle.R")
stedsnavn(test$Longitude, test$Latitude)
lon <- test$Longitude
lat <- test$Latitude
output <- data.frame(county = "",
municipality = "",
locality = "",
type = "",
dist_m = "",
orient <- "")
# Loop over input coordinates
for (i in 1:length(lon)) {
# add longitude and latitude to new variables
x = lat[i]
y = lon[i]
# Define boundary box
x1 = x # Lower left N coordinate
y1 = y # Lower left E coordinate
x2 = x # Upper Right N coordinate
y2 = y # Upper Right E coordinate
Loc_df <- NULL
for (q in 1:50){
# Expand target area by some degrees in each direction. Longitudes 3*latitudes to make the increase more or less square-like.
x1 = (x1*10^4-6)/10^4
y1 = (y1*10^4-17)/10^4
x2 = (x2*10^4+6)/10^4
y2 = (y2*10^4+17)/10^4
# Search for a locality name within the given coordinates
xURL <- paste("https://ws.geonorge.no/SKWS3Index/ssr/sok?nordLL=", x1, "&ostLL=", y1, "&nordUR=", x2, "&ostUR=", y2, "&epsgKode=", 4258, sep = "")
xml_temp <- getURL(xURL, .encoding = "latin1")
xml_temp2<- xmlTreeParse(xml_temp, useInternalNodes = TRUE)
Loc_df <- xmlToDataFrame(xml_temp2)
#Stop loop at first hit
if (is.null(Loc_df[3,8])==FALSE) {
break
}
else {
next
}
}
# Calculate distnce and angle between input coordinates and locality-name
A <- as.numeric(Loc_df[3,9])
B <- as.numeric(Loc_df[3,10])
D <- points2dist(A, B, y, x)
A <- points2angle(A, B, y, x)
# Add search results to input table
output$county[i] <- Loc_df[3,7]
output$municipality[i] <- Loc_df[3,6]
output$locality[i] <- Loc_df[3,8]
output$type[i] <- Loc_df[3,5]
output$dist_m[i] <- round(D)
output$orient[i] <- A
}
return(output)
output
View(output)
length(lon)
# Loop over input coordinates
for (i in 1:length(lon)) {
# add longitude and latitude to new variables
x = lat[i]
y = lon[i]
# Define boundary box
x1 = x # Lower left N coordinate
y1 = y # Lower left E coordinate
x2 = x # Upper Right N coordinate
y2 = y # Upper Right E coordinate
Loc_df <- NULL
for (q in 1:50){
# Expand target area by some degrees in each direction. Longitudes 3*latitudes to make the increase more or less square-like.
x1 = (x1*10^4-6)/10^4
y1 = (y1*10^4-17)/10^4
x2 = (x2*10^4+6)/10^4
y2 = (y2*10^4+17)/10^4
# Search for a locality name within the given coordinates
xURL <- paste("https://ws.geonorge.no/SKWS3Index/ssr/sok?nordLL=", x1, "&ostLL=", y1, "&nordUR=", x2, "&ostUR=", y2, "&epsgKode=", 4258, sep = "")
xml_temp <- getURL(xURL, .encoding = "latin1")
xml_temp2<- xmlTreeParse(xml_temp, useInternalNodes = TRUE)
Loc_df <- xmlToDataFrame(xml_temp2)
#Stop loop at first hit
if (is.null(Loc_df[3,8])==FALSE) {
break
}
else {
next
}
}
# Calculate distnce and angle between input coordinates and locality-name
A <- as.numeric(Loc_df[3,9])
B <- as.numeric(Loc_df[3,10])
D <- points2dist(A, B, y, x)
A <- points2angle(A, B, y, x)
# Add search results to input table
output$county[i] <- Loc_df[3,7]
output$municipality[i] <- Loc_df[3,6]
output$locality[i] <- Loc_df[3,8]
output$type[i] <- Loc_df[3,5]
output$dist_m[i] <- round(D)
output$orient[i] <- A
}
# Loop over input coordinates
#for (i in 1:length(lon)) {
# add longitude and latitude to new variables
x = lat[1]
y = lon[1]
# Define boundary box
x1 = x # Lower left N coordinate
y1 = y # Lower left E coordinate
x2 = x # Upper Right N coordinate
y2 = y # Upper Right E coordinate
Loc_df <- NULL
for (q in 1:50){
# Expand target area by some degrees in each direction. Longitudes 3*latitudes to make the increase more or less square-like.
x1 = (x1*10^4-6)/10^4
y1 = (y1*10^4-17)/10^4
x2 = (x2*10^4+6)/10^4
y2 = (y2*10^4+17)/10^4
# Search for a locality name within the given coordinates
xURL <- paste("https://ws.geonorge.no/SKWS3Index/ssr/sok?nordLL=", x1, "&ostLL=", y1, "&nordUR=", x2, "&ostUR=", y2, "&epsgKode=", 4258, sep = "")
xml_temp <- getURL(xURL, .encoding = "latin1")
xml_temp2<- xmlTreeParse(xml_temp, useInternalNodes = TRUE)
Loc_df <- xmlToDataFrame(xml_temp2)
#Stop loop at first hit
if (is.null(Loc_df[3,8])==FALSE) {
break
}
else {
next
}
}
# Calculate distnce and angle between input coordinates and locality-name
A <- as.numeric(Loc_df[3,9])
B <- as.numeric(Loc_df[3,10])
D <- points2dist(A, B, y, x)
A <- points2angle(A, B, y, x)
# Add search results to input table
output$county[1] <- Loc_df[3,7]
output$municipality[1] <- Loc_df[3,6]
output$locality[1] <- Loc_df[3,8]
output$type[1] <- Loc_df[3,5]
output$dist_m[1] <- round(D)
output$orient[1] <- A
View(output)
# Loop over input coordinates
#for (i in 1:length(lon)) {
# add longitude and latitude to new variables
x = lat[2]
y = lon[2]
# Define boundary box
x1 = x # Lower left N coordinate
y1 = y # Lower left E coordinate
x2 = x # Upper Right N coordinate
y2 = y # Upper Right E coordinate
Loc_df <- NULL
for (q in 1:50){
# Expand target area by some degrees in each direction. Longitudes 3*latitudes to make the increase more or less square-like.
x1 = (x1*10^4-6)/10^4
y1 = (y1*10^4-17)/10^4
x2 = (x2*10^4+6)/10^4
y2 = (y2*10^4+17)/10^4
# Search for a locality name within the given coordinates
xURL <- paste("https://ws.geonorge.no/SKWS3Index/ssr/sok?nordLL=", x1, "&ostLL=", y1, "&nordUR=", x2, "&ostUR=", y2, "&epsgKode=", 4258, sep = "")
xml_temp <- getURL(xURL, .encoding = "latin1")
xml_temp2<- xmlTreeParse(xml_temp, useInternalNodes = TRUE)
Loc_df <- xmlToDataFrame(xml_temp2)
#Stop loop at first hit
if (is.null(Loc_df[3,8])==FALSE) {
break
}
else {
next
}
}
# Calculate distnce and angle between input coordinates and locality-name
A <- as.numeric(Loc_df[3,9])
B <- as.numeric(Loc_df[3,10])
D <- points2dist(A, B, y, x)
A <- points2angle(A, B, y, x)
# Add search results to input table
output$county[2] <- Loc_df[3,7]
output <- data.frame(lon,
lat,
county = "",
municipality = "",
locality = "",
type = "",
dist_m = "",
orient <- "")
View(output)
# Loop over input coordinates
#for (i in 1:length(lon)) {
# add longitude and latitude to new variables
x = lat[1]
y = lon[1]
# Define boundary box
x1 = x # Lower left N coordinate
y1 = y # Lower left E coordinate
x2 = x # Upper Right N coordinate
y2 = y # Upper Right E coordinate
Loc_df <- NULL
for (q in 1:50){
# Expand target area by some degrees in each direction. Longitudes 3*latitudes to make the increase more or less square-like.
x1 = (x1*10^4-6)/10^4
y1 = (y1*10^4-17)/10^4
x2 = (x2*10^4+6)/10^4
y2 = (y2*10^4+17)/10^4
# Search for a locality name within the given coordinates
xURL <- paste("https://ws.geonorge.no/SKWS3Index/ssr/sok?nordLL=", x1, "&ostLL=", y1, "&nordUR=", x2, "&ostUR=", y2, "&epsgKode=", 4258, sep = "")
xml_temp <- getURL(xURL, .encoding = "latin1")
xml_temp2<- xmlTreeParse(xml_temp, useInternalNodes = TRUE)
Loc_df <- xmlToDataFrame(xml_temp2)
#Stop loop at first hit
if (is.null(Loc_df[3,8])==FALSE) {
break
}
else {
next
}
}
# Calculate distnce and angle between input coordinates and locality-name
A <- as.numeric(Loc_df[3,9])
B <- as.numeric(Loc_df[3,10])
D <- points2dist(A, B, y, x)
A <- points2angle(A, B, y, x)
# Add search results to input table
output$county[1] <- Loc_df[3,7]
output$municipality[1] <- Loc_df[3,6]
output$locality[1] <- Loc_df[3,8]
output$type[1] <- Loc_df[3,5]
output$dist_m[1] <- round(D)
output$orient[1] <- A
output <- data.frame(lon,
lat,
county = "",
municipality = "",
locality = "",
type = "",
dist_m = "",
orient <- "")
# Loop over input coordinates
for (i in 1:length(lon)) {
# add longitude and latitude to new variables
x = lat[i]
y = lon[i]
# Define boundary box
x1 = x # Lower left N coordinate
y1 = y # Lower left E coordinate
x2 = x # Upper Right N coordinate
y2 = y # Upper Right E coordinate
Loc_df <- NULL
for (q in 1:50){
# Expand target area by some degrees in each direction. Longitudes 3*latitudes to make the increase more or less square-like.
x1 = (x1*10^4-6)/10^4
y1 = (y1*10^4-17)/10^4
x2 = (x2*10^4+6)/10^4
y2 = (y2*10^4+17)/10^4
# Search for a locality name within the given coordinates
xURL <- paste("https://ws.geonorge.no/SKWS3Index/ssr/sok?nordLL=", x1, "&ostLL=", y1, "&nordUR=", x2, "&ostUR=", y2, "&epsgKode=", 4258, sep = "")
xml_temp <- getURL(xURL, .encoding = "latin1")
xml_temp2<- xmlTreeParse(xml_temp, useInternalNodes = TRUE)
Loc_df <- xmlToDataFrame(xml_temp2)
#Stop loop at first hit
if (is.null(Loc_df[3,8])==FALSE) {
break
}
else {
next
}
}
# Calculate distnce and angle between input coordinates and locality-name
A <- as.numeric(Loc_df[3,9])
B <- as.numeric(Loc_df[3,10])
D <- points2dist(A, B, y, x)
A <- points2angle(A, B, y, x)
# Add search results to input table
output$county[i] <- Loc_df[3,7]
output$municipality[i] <- Loc_df[3,6]
output$locality[i] <- Loc_df[3,8]
output$type[i] <- Loc_df[3,5]
output$dist_m[i] <- round(D)
output$orient[i] <- A
}
View(output)
round(D)
ncol(output)
output <- data.frame(lon,
lat,
county = "",
municipality = "",
locality = "",
type = "",
dist_m = "",
orient <- "")
View(output)
output <- data.frame(lon,
lat,
county = "",
municipality = "",
locality = "",
type = "",
dist_m = "",
orient = "")
View(output)
# Loop over input coordinates
for (i in 1:length(lon)) {
# add longitude and latitude to new variables
x = lat[i]
y = lon[i]
# Define boundary box
x1 = x # Lower left N coordinate
y1 = y # Lower left E coordinate
x2 = x # Upper Right N coordinate
y2 = y # Upper Right E coordinate
Loc_df <- NULL
for (q in 1:50){
# Expand target area by some degrees in each direction. Longitudes 3*latitudes to make the increase more or less square-like.
x1 = (x1*10^4-6)/10^4
y1 = (y1*10^4-17)/10^4
x2 = (x2*10^4+6)/10^4
y2 = (y2*10^4+17)/10^4
# Search for a locality name within the given coordinates
xURL <- paste("https://ws.geonorge.no/SKWS3Index/ssr/sok?nordLL=", x1, "&ostLL=", y1, "&nordUR=", x2, "&ostUR=", y2, "&epsgKode=", 4258, sep = "")
xml_temp <- getURL(xURL, .encoding = "latin1")
xml_temp2<- xmlTreeParse(xml_temp, useInternalNodes = TRUE)
Loc_df <- xmlToDataFrame(xml_temp2)
#Stop loop at first hit
if (is.null(Loc_df[3,8])==FALSE) {
break
}
else {
next
}
}
# Calculate distnce and angle between input coordinates and locality-name
A <- as.numeric(Loc_df[3,9])
B <- as.numeric(Loc_df[3,10])
D <- points2dist(A, B, y, x)
A <- points2angle(A, B, y, x)
# Add search results to input table
output$county[i] <- Loc_df[3,7]
output$municipality[i] <- Loc_df[3,6]
output$locality[i] <- Loc_df[3,8]
output$type[i] <- Loc_df[3,5]
output$dist_m[i] <- round(D)
output$orient[i] <- A
}
View(output)
return(output)
output[,c(3:8)]
#' Returns strand-codes
#'
#' Returns Strand-codes from one, or a set of input coordinates (projection longlat, datum WGS84). The strand-codes are obtained by identifying the intesects beween the input coordinates and a polygon dataset of the Strand regions (created by Endrestøl 2021, following the revision of the Strand-system by Økland 1981)
#' @param lon a numerical value, or vetor of numerical values, that specifies the longitude(s) in the input coordinate(s)
#' @param lat a numerical value, or vetor of numerical values, that specifies the longitude(s) in the input coordinate(s)
#' @return Returns a dataframe with Strand-codes
#' @examples example_output <- strandkoder(lon = c(24.840064, 23.186622), lat = c(69.57696, 70.44070))
#' @import sp
#' @export
strandkoder <- function(lon, lat) {
# Save longlat projection to variable
ll_prj <- "+proj=longlat +datum=WGS84"
# Import coordinates dataset
lonlat <- data.frame(lon, lat)
# Convert decimal-longlat to SpatialPoints class, with projection longlat datum wgs84
pts <- SpatialPoints(lonlat, CRS(ll_prj))
# Convert 'strand' spatial polygons dataframe to projection longlat and datum wgs84
strand.4.0 <- spTransform(strand, CRS(ll_prj))
# Identify municipalities intersecting with input coordinates
strand_codes <- over(pts, strand)
# Return dataframe
return(strand_codes)
}
strandkoder(lon = test$Longitude, lat = test$Latitude)
load("~/Scripts/R/Packages/strandr/R/sysdata.rda")
strandkoder(lon = test$Longitude, lat = test$Latitude)
#'
#' Returns Strand-codes from one, or a set of input coordinates (projection longlat, datum WGS84). The strand-codes are obtained by identifying the intesects beween the input coordinates and a polygon dataset of the Strand regions (created by Endrestøl 2021, following the revision of the Strand-system by Økland 1981)
#' @param lon a numerical value, or vetor of numerical values, that specifies the longitude(s) in the input coordinate(s)
#' @param lat a numerical value, or vetor of numerical values, that specifies the longitude(s) in the input coordinate(s)
#' @return Returns a dataframe with Strand-codes
#' @examples example_output <- strandkoder(lon = c(24.840064, 23.186622), lat = c(69.57696, 70.44070))
#' @import sp
#' @export
#strandkoder <- function(lon, lat) {
# Save longlat projection to variable
ll_prj <- "+proj=longlat +datum=WGS84"
# Import coordinates dataset
lonlat <- data.frame(lon, lat)
View(lonlat)
# Convert decimal-longlat to SpatialPoints class, with projection longlat datum wgs84
pts <- SpatialPoints(lonlat, CRS(ll_prj))
# Convert 'strand' spatial polygons dataframe to projection longlat and datum wgs84
strand.4.0 <- spTransform(strand, CRS(ll_prj))
# Identify municipalities intersecting with input coordinates
strand_codes <- over(pts, strand)
proj4string(strand.4.0)
proj4string(pts)
# Identify municipalities intersecting with input coordinates
strand_codes <- over(pts, strand.4.0)
View(strand_codes)
strand_codes[,2]
test <- read.table("koordinater.txt")
load("~/Scripts/R/Packages/strandr/R/sysdata.rda")
test <- read.table("koordinater.txt", header = TRUE)
lon = test$Longitude
lat = test$Latitude
#'
#' Returns Strand-codes from one, or a set of input coordinates (projection longlat, datum WGS84). The strand-codes are obtained by identifying the intesects beween the input coordinates and a polygon dataset of the Strand regions (created by Endrestøl 2021, following the revision of the Strand-system by Økland 1981)
#' @param lon a numerical value, or vetor of numerical values, that specifies the longitude(s) in the input coordinate(s)
#' @param lat a numerical value, or vetor of numerical values, that specifies the longitude(s) in the input coordinate(s)
#' @return Returns a dataframe with Strand-codes
#' @examples example_output <- strandkoder(lon = c(24.840064, 23.186622), lat = c(69.57696, 70.44070))
#' @import sp
#' @export
#strandkoder <- function(lon, lat) {
# Save longlat projection to variable
ll_prj <- "+proj=longlat +datum=WGS84"
# Import coordinates dataset
lonlat <- data.frame(lon, lat)
# Convert decimal-longlat to SpatialPoints class, with projection longlat datum wgs84
pts <- SpatialPoints(lonlat, CRS(ll_prj))
# Convert 'strand' spatial polygons dataframe to projection longlat and datum wgs84
strand.4.0 <- spTransform(strand, CRS(ll_prj))
# Identify municipalities intersecting with input coordinates
strand_codes <- over(pts, strand.4.0)
strand_codes[,2]
strand_codes[,c(2)]
data.frame(strand_codes[,2])
strand_codes
summary(strand_codes)
try <- summary(strand_codes[,2])
try <- strand_codes[,2]
try <- strand_codes$Strandkode
try <- data.frame(strand_codes)
try[,2]
data.frame(try[,2], try[,3])
data.frame(strand = strand_codes[,2])
try <- data.frame(strand = strand_codes[,2])
library(strandr)
devtools::load_all(".")
rm(list = c("strand"))
devtools::load_all(".")
library(roxygen2)
library(github)
library(devtools)
library(strandr)
library(roxygen2)
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::namespace_roclet()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
load("~/Scripts/R/Packages/strandr/R/sysdata.rda")
devtools::load_all(".")
rm(list = c("strand"))
devtools::load_all(".")
knitr::opts_chunk$set(echo = TRUE)
eks_inn <- read.table("koordinater.txt", sep = "\t", header = TRUE)
eks_inn
library(strandr)
eks_ut <- strandr(eks_inn, lon = eks_inn$Longitude, lat = eks_inn$Latitude)
eks_inn$longitude
summary(eks_inn)
eks_ut <- strandr(eks_inn, lon = eks_inn$longitude, lat = eks_inn$latitude)
eks_ut
eks_inn # Sjekk ut tabellen
